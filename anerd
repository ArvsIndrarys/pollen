#!/usr/bin/python
#
#    anerd: Asynchronous Network Exchanged Randomness Daemon
#    Copyright (C) 2012 Dustin Kirkland <dustin.kirkland@gmail.com>
#
#    Authors: Dustin Kirkland <dustin.kirkland@gmail.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

from contextlib import closing
import datetime
import hashlib
import multiprocessing
import os
import random
import signal
import socket
import sys
import time

PKG = "anerd"
UDP_IP = ""
UDP_PORT = 26373
MSG_SIZE = 64
RND_DEVICE = "/dev/urandom"
EXIT_FLAG = 0
INTERVAL = 60


def anerd_server():
	"""Exchange randomness upon request."""
	last = datetime.datetime.now()
	sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	sock.bind((UDP_IP, UDP_PORT))
	print "Started aNerdServer"
	# Listen and respond to incoming requests
	while EXIT_FLAG == 0:
		# Receive message
		data, addr = sock.recvfrom(MSG_SIZE)
		# Calculate the microsecond delta between requests
		delta = (datetime.datetime.now() - last).microseconds
		# Unpredictably salt the non-secret network input
		salt = hashlib.md5(str(delta) + os.urandom(MSG_SIZE/2)).digest()
		print "Received [%s] bytes from [%s], checksum [%s], delta [%s]" % (
				len(data), addr, hashlib.md5(data).hexdigest(), delta)
		# Add the incoming entropy to the pool
		with closing(open(RND_DEVICE, "w")) as f:
			f.write(salt + data)
		last = datetime.datetime.now()
		# Reply with as much entropy as we recevied,
		# up to MSG_SIZE maximum
		with closing(open(RND_DEVICE, "r")) as f:
			response = f.read(len(data))
		print "Sending [%s] bytes to [%s], checksum [%s]" % (
				len(response), addr, hashlib.md5(response).hexdigest())
		sock.sendto(response, addr)


def anerd_client():
	"""Periodically initiate randomness exchange with peers."""
	sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	sock.bind(('', 0))
	sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
	print "Started aNerdClient"
	while INTERVAL > 0 and EXIT_FLAG == 0:
		with closing(open(RND_DEVICE, "r")) as f:
			data = f.read(MSG_SIZE)
		sock.sendto(data, ('<broadcast>', UDP_PORT))
		print "Broadcasting [%s] bytes, checksum [%s]" % (
				len(data), hashlib.md5(data).hexdigest())
		time.sleep(INTERVAL + random.random())


def signal_handler(signal, frame):
	"""Set exit flag, and exit."""
	EXIT_FLAG = 1
	sys.exit(0)


# Handle signals appropriately
signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGABRT, signal_handler)

# Create server and client processes
server = multiprocessing.Process(target=anerd_server, args=())
client = multiprocessing.Process(target=anerd_client, args=())
server.start()
client.start()
server.join()
client.join()
